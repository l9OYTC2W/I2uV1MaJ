function spm_render2(dat,brt,rendfile)
% Render blobs on surface of a 'standard' brain
% FORMAT spm_render(dat,brt,rendfile)
%
% dat - a vertical cell array of length 1 to 3
%       - each element is a structure containing:
%         - XYZ - the x, y & z coordinates of the transformed t values.
%                 in units of voxels.
%         - t   - the SPM{.} values
%         - mat - affine matrix mapping from XYZ voxels to Talairach.
%         - dim - dimensions of volume from which XYZ is drawn.
% brt - brightness control:
%            If NaN, then displays using the old style with hot
%            metal for the blobs, and grey for the brain.
%            Otherwise, it is used as a ``gamma correction'' to
%            optionally brighten the blobs up a little.
% rendfile - the file containing the images to render on to. See also
%            spm_xbrain.m.
%
% Without arguments, spm_render acts as its own UI.
%_______________________________________________________________________
% 
% spm_render prompts for details of up to three SPM{Z}s or SPM{t}s that
% are then displayed superimposed on the surface of a standard brain.
%
% The first is shown in red, then green then blue.
%
% The blobs which are displayed are the integral of all transformed t
% values, exponentially decayed according to their depth. Voxels that
% are 10mm behind the surface have half the intensity of ones at the
% surface.
%_______________________________________________________________________
% @(#)spm_render.m	2.19 John Ashburner FIL 02/10/29

%-Parse arguments, get data if not passed as parameters
%=======================================================================
% MODIFED ON 2-8-04 by Eric Egolf
% Functionality extended to look at multiple sets using the old style of
% highlighting.
% Modified colormaps to look better, allows user to select which colormap
% each set uses. 
% Also allows overlay map.





if nargin < 1
	SPMid = spm('FnBanner',mfilename,'2.19');
	[Finter,Fgraph,CmdLine] = spm('FnUIsetup','Results: render',0);

	num   = spm_input('Number of sets',1,'1 set|2 sets|3 sets',[1 2 3]);

	for i = 1:num,
		[SPM,VOL] = spm_getSPM;
		dat(i)    = struct(	'XYZ',	VOL.XYZ,...
					't',	VOL.Z',...
					'mat',	VOL.M,...
					'dim',	VOL.DIM);
	end;
	showbar = 1;
else,
	num     = length(dat);
	showbar = 0;
end;

% get surface
%-----------------------------------------------------------------------
if nargin < 3,
	rendfile = spm_get(1,'render*.mat','Render file',fullfile(spm('Dir'),'rend'));
end;

% get brightness
%-----------------------------------------------------------------------
if nargin < 2,
	brt = 1;
    %*modified by eric egolf 04
	if num<=3,
		brt = spm_input('Style',1,'new|old',[1 NaN], 1);
          
        if(num>1 & ~isfinite(brt))
            isOldAndMultiImages = 2;
        else
            isOldAndMultiImages = 1;
        end
        
	end;
	if isfinite(brt),
		brt = spm_input('Brighten blobs',1,'none|slightly|more|lots',[1 0.75 0.5 0.25], 1);
        isOldAndMultiImages = 0;
	end;
end;



% Perform the rendering
%=======================================================================
spm('Pointer','Watch')

load(rendfile);

if (exist('rend') ~= 1), % Assume old format...
	rend = cell(size(Matrixes,1),1);
	for i=1:size(Matrixes,1),
		rend{i}=struct('M',eval(Matrixes(i,:)),...
			'ren',eval(Rens(i,:)),...
			'dep',eval(Depths(i,:)));
		rend{i}.ren = rend{i}.ren/max(max(rend{i}.ren));
	end;
end;

if showbar, spm_progress_bar('Init', size(dat,1)*length(rend),...
			'Formatting Renderings', 'Number completed'); end;
for i=1:length(rend),
	rend{i}.max=0;
	rend{i}.data = cell(size(dat,1),1);
	if issparse(rend{i}.ren),
		% Assume that images have been DCT compressed
		% - the SPM99 distribution was originally too big.
		d = size(rend{i}.ren);
		B1 = spm_dctmtx(d(1),d(1));
		B2 = spm_dctmtx(d(2),d(2));
		rend{i}.ren = B1*rend{i}.ren*B2';
		% the depths did not compress so well with
		% a straight DCT - therefore it was modified slightly
		rend{i}.dep = exp(B1*rend{i}.dep*B2')-1;
	end;
	msk = find(rend{i}.ren>1);rend{i}.ren(msk)=1;
	msk = find(rend{i}.ren<0);rend{i}.ren(msk)=0;
	if showbar, spm_progress_bar('Set', i); end;
end;
if showbar, spm_progress_bar('Clear'); end;

if showbar, spm_progress_bar('Init', length(dat)*length(rend),...
			'Making pictures', 'Number completed'); end;

mx = zeros(length(rend),1)+eps;
mn = zeros(length(rend),1);

for j=1:length(dat),
	XYZ = dat(j).XYZ;
	t   = dat(j).t;
	dim = dat(j).dim;
	mat = dat(j).mat;

	for i=1:length(rend),

		% transform from Taliarach space to space of the rendered image
		%-------------------------------------------------------
		M1  = rend{i}.M*dat(j).mat;
		zm  = sum(M1(1:2,1:3).^2,2).^(-1/2);
		M2  = diag([zm' 1 1]);
		M  = M2*M1;
		cor = [1 1 1 ; dim(1) 1 1 ; 1 dim(2) 1; dim(1) dim(2) 1 ;
		       1 1 dim(3) ; dim(1) 1 dim(3) ; 1 dim(2) dim(3); dim(1) dim(2) dim(3)]';
		tcor= M(1:3,1:3)*cor + M(1:3,4)*ones(1,8);
		off = min(tcor(1:2,:)');
		M2  = spm_matrix(-off+1)*M2;
		M  = M2*M1;
		xyz = (M(1:3,1:3)*XYZ + M(1:3,4)*ones(1,size(XYZ,2)));
		d2  = ceil(max(xyz(1:2,:)'));

		% calculate 'depth' of values
		%-------------------------------------------------------
		dep = spm_slice_vol(rend{i}.dep,spm_matrix([0 0 1])*inv(M2),d2,1);
		z1  = dep(round(xyz(1,:))+round(xyz(2,:)-1)*size(dep,1));

        %_________________ADDEDED EAE
		if isOldAndMultiImages, msk = find(xyz(3,:) < (z1+20) & xyz(3,:) > (z1-5));
		else,      msk = find(xyz(3,:) < (z1+60) & xyz(3,:) > (z1-5)); end;

		if ~isempty(msk),

			% generate an image of the integral of the blob values.
			%-----------------------------------------------
			xyz = xyz(:,msk);
			if isOldAndMultiImages, t0  = t(msk);
			else,	dst = xyz(3,:) - z1(msk);
				dst = max(dst,0);
				t0  = t(msk).*exp((log(0.5)/10)*dst)';
			end;
			X0  = full(sparse(round(xyz(1,:)), round(xyz(2,:)), t0, d2(1), d2(2)));
			hld = 1; if isOldAndMultiImages, hld = 0; end;
			X   = spm_slice_vol(X0,spm_matrix([0 0 1])*M2,size(rend{i}.dep),hld);
			msk = find(X<0);
			X(msk) = 0;
		else,
			X = zeros(size(rend{i}.dep));
		end;

		% Brighten the blobs
		if ~isOldAndMultiImages, X = X.^brt; end;

		mx(j) = max([mx(j) max(max(X))]);
		mn(j) = min([mn(j) min(min(X))]);

		rend{i}.data{j} = X;

		if showbar, spm_progress_bar('Set', i+(j-1)*length(rend)); end;
	end;
end;

mxmx = max(mx);
mnmn = min(mn);

if showbar, spm_progress_bar('Clear'); end;
Fgraph = spm_figure('GetWin','Graphics');
spm_results_ui('Clear',Fgraph);

nrow = ceil(length(rend)/2);
if showbar, hght = 0.95; else, hght = 0.5; end;
% subplot('Position',[0, 0, 1, hght]);
ax=axes('Parent',Fgraph,'units','normalized','Position',[0, 0, 1, hght],'Visible','off');
image(0,'Parent',ax);
set(ax,'YTick',[],'XTick',[]);

if (isOldAndMultiImages),
	% Old style split colourmap display.
	%---------------------------------------------------------------
	
    %get colormaps;
    load Split;
%     colormap(split);
    cm1 = split;%added
%     cm2 = split(:,[3 2 1]);%added
	strCM = cm1(1:64,:);%added
%     hot = cm1(65:128,:);%added
%     cold = cm2(65:128,:);%added
    cold2=   [ 0         0    0.4000;,...
         0         0    0.4261;,...
         0         0    0.4522;,...
         0         0    0.4783;,...
         0         0    0.5043;,...
         0         0    0.5304;,...
         0         0    0.5565;,...
         0         0    0.5826;,...
         0         0    0.6087;,...
         0         0    0.6348;,...
         0         0    0.6609;,...
         0         0    0.6870;,...
         0         0    0.7130;,...
         0         0    0.7391;,...
         0         0    0.7652;,...
         0         0    0.7913;,...
         0         0    0.8174;,...
         0         0    0.8435;,...
         0         0    0.8696;,...
         0         0    0.8957;,...
         0         0    0.9217;,...
         0         0    0.9478;,...
         0         0    0.9739;,...
         0         0    1.0000;,...
         0    0.0417    1.0000;,...
         0    0.0833    1.0000;,...
         0    0.1250    1.0000;,...
         0    0.1667    1.0000;,...
         0    0.2083    1.0000;,...
         0    0.2500    1.0000;,...
         0    0.2917    1.0000;,...
         0    0.3333    1.0000;,...
         0    0.3750    1.0000;,...
         0    0.4167    1.0000;,...
         0    0.4583    1.0000;,...
         0    0.5000    1.0000;,...
         0    0.5417    1.0000;,...
         0    0.5833    1.0000;,...
         0    0.6250    1.0000;,...
         0    0.6667    1.0000;,...
         0    0.7083    1.0000;,...
         0    0.7500    1.0000;,...
         0    0.7917    1.0000;,...
         0    0.8333    1.0000;,...
         0    0.8750    1.0000;,...
         0    0.9167    1.0000;,...
         0    0.9583    1.0000;,...
         0    1.0000    1.0000;,...
    0.0625    1.0000    1.0000;,...
    0.1250    1.0000    1.0000;,...
    0.1875    1.0000    1.0000;,...
    0.2500    1.0000    1.0000;,...
    0.3125    1.0000    1.0000;,...
    0.3750    1.0000    1.0000;,...
    0.4375    1.0000    1.0000;,...
    0.5000    1.0000    1.0000;,...
    0.5625    1.0000    1.0000;,...
    0.6250    1.0000    1.0000;,...
    0.6875    1.0000    1.0000;,...
    0.7500    1.0000    1.0000;,...
    0.8125    1.0000    1.0000;,...
    0.8750    1.0000    1.0000;,...
    0.9375    1.0000    1.0000;,...
    1.0000    1.0000    1.0000];

hot2 = [0.4745         0         0;,...
    0.4974         0         0;,...
    0.5202         0         0;,...
    0.5431         0         0;,...
    0.5659         0         0;,...
    0.5887         0         0;,...
    0.6116         0         0;,...
    0.6344         0         0;,...
    0.6573         0         0;,...
    0.6801         0         0;,...
    0.7030         0         0;,...
    0.7258         0         0;,...
    0.7487         0         0;,...
    0.7715         0         0;,...
    0.7944         0         0;,...
    0.8172         0         0;,...
    0.8401         0         0;,...
    0.8629         0         0;,...
    0.8858         0         0;,...
    0.9086         0         0;,...
    0.9315         0         0;,...
    0.9543         0         0;,...
    0.9772         0         0;,...
    1.0000         0         0;,...
    1.0000    0.0417         0;,...
    1.0000    0.0833         0;,...
    1.0000    0.1250         0;,...
    1.0000    0.1667         0;,...
    1.0000    0.2083         0;,...
    1.0000    0.2500         0;,...
    1.0000    0.2917         0;,...
    1.0000    0.3333         0;,...
    1.0000    0.3750         0;,...
    1.0000    0.4167         0;,...
    1.0000    0.4583         0;,...
    1.0000    0.5000         0;,...
    1.0000    0.5417         0;,...
    1.0000    0.5833         0;,...
    1.0000    0.6250         0;,...
    1.0000    0.6667         0;,...
    1.0000    0.7083         0;,...
    1.0000    0.7500         0;,...
    1.0000    0.7917         0;,...
    1.0000    0.8333         0;,...
    1.0000    0.8750         0;,...
    1.0000    0.9167         0;,...
    1.0000    0.9583         0;,...
    1.0000    1.0000         0;,...
    1.0000    1.0000    0.0625;,...
    1.0000    1.0000    0.1250;,...
    1.0000    1.0000    0.1875;,...
    1.0000    1.0000    0.2500;,...
    1.0000    1.0000    0.3125;,...
    1.0000    1.0000    0.3750;,...
    1.0000    1.0000    0.4375;,...
    1.0000    1.0000    0.5000;,...
    1.0000    1.0000    0.5625;,...
    1.0000    1.0000    0.6250;,...
    1.0000    1.0000    0.6875;,...
    1.0000    1.0000    0.7500;,...
    1.0000    1.0000    0.8125;,...
    1.0000    1.0000    0.8750;,...
    1.0000    1.0000    0.9375;,...
    1.0000    1.0000    1.0000];


    green2=    [0.0417         0         0;,...
    0.0399    0.0218    0.0218;,...
    0.0380    0.0436    0.0436;,...
    0.0362    0.0655    0.0655;,...
    0.0344    0.0873    0.0873;,...
    0.0326    0.1091    0.1091;,...
    0.0308    0.1309    0.1309;,...
    0.0290    0.1528    0.1528;,...
    0.0272    0.1746    0.1746;,...
    0.0254    0.1964    0.1964;,...
    0.0236    0.2182    0.2182;,...
    0.0217    0.2401    0.2401;,...
    0.0199    0.2619    0.2619;,...
    0.0181    0.2837    0.2837;,...
    0.0163    0.3055    0.3055;,...
    0.0145    0.3274    0.3274;,...
    0.0127    0.3492    0.3492;,...
    0.0109    0.3710    0.3710;,...
    0.0091    0.3928    0.3928;,...
    0.0072    0.4147    0.4147;,...
    0.0054    0.4365    0.4365;,...
    0.0036    0.4583    0.4583;,...
    0.0018    0.4801    0.4801;,...
         0    0.5020    0.5020;,...
         0    0.5227    0.5020;,...
         0    0.5435    0.5020;,...
         0    0.5642    0.5020;,...
         0    0.5850    0.5020;,...
         0    0.6057    0.5020;,...
         0    0.6265    0.5020;,...
         0    0.6472    0.5020;,...
         0    0.6680    0.5020;,...
         0    0.6887    0.5020;,...
         0    0.7095    0.5020;,...
         0    0.7302    0.5020;,...
         0    0.7510    0.5020;,...
         0    0.7717    0.5020;,...
         0    0.7925    0.5020;,...
         0    0.8132    0.5020;,...
         0    0.8340    0.5020;,...
         0    0.8547    0.5020;,...
         0    0.8755    0.5020;,...
         0    0.8962    0.5020;,...
         0    0.9170    0.5020;,...
         0    0.9377    0.5020;,...
         0    0.9585    0.5020;,...
         0    0.9792    0.5020;,...
         0    1.0000    0.5020;,...
    0.0625    1.0000    0.5331;,...
    0.1250    1.0000    0.5642;,...
    0.1875    1.0000    0.5953;,...
    0.2500    1.0000    0.6265;,...
    0.3125    1.0000    0.6576;,...
    0.3750    1.0000    0.6887;,...
    0.4375    1.0000    0.7199;,...
    0.5000    1.0000    0.7510;,...
    0.5625    1.0000    0.7821;,...
    0.6250    1.0000    0.8132;,...
    0.6875    1.0000    0.8444;,...
    0.7500    1.0000    0.8755;,...
    0.8125    1.0000    0.9066;,...
    0.8750    1.0000    0.9377;,...
    0.9375    1.0000    0.9689;,...
    1.0000    1.0000    1.0000];%added

    

    if(length(rend{1}.data) ==2)
        useOverlapColor = spm_input('Use colormap for overlap','+1','m','Yes|No',[1 0]);    
    else
        useOverlapColor = 0;
    end
    

    
    
    if(useOverlapColor)
        for i=1:length(rend)
            %load images
            image1 = (rend{i}.data{1}-mnmn)/(mxmx-mnmn);
            image2 = (rend{i}.data{2}-mnmn)/(mxmx-mnmn);
            msk1 = zeros(size(image1));
            msk2 = msk1;
            msk3 = msk1;
            
            %get binary masks
            msk1(find(image1)) = 1;
            msk2(find(image2)) = 1;
            
            
            %make new binary
            msk31 = zeros(size(image1));
            msk31(find(msk1&msk2)) =1;
            msk11 = msk31;
            msk21 = msk31;
            msk31 = msk31;
            msk11(find(msk1==1 & msk31==0)) = 1;
            msk21(find(msk2==1 & msk31==0))=1;
            clear msk1;clear msk2;clear msk3;
            
            %get voxel values based on masks
            %             image1 = rend{i}.data{1};
            %             image2 = rend{i}.data{2};
            %             tempIM1 = zeros(size(image1));
            %             tempIM2 = tempIM1;
            %             tempIM3 = tempIM1;
            %             tempIM1(find(msk11)) = image1(find(msk11));
            %             tempIM2(find(msk21)) = image2(find(msk21));
            %             tempIM3(find(msk31)) = max(image1(find(msk31)),image2(find(msk31)));
            %             clear image1;clear image2;
            %             
            %set new values
            rend{i}.data{1} =msk11;
            rend{i}.data{2} = msk21;
            rend{i}.data{3} = msk31;
            clear tempIM1;clear tempIM2;clear tempIM3;
            titleString = ['Red = 1st Set, Yellow = 2nd Set, Orange = Overlap'];
            
            
        end
        %colormaps
        yellow = [1.0000    .9795    0.0156];
        red =[1     0     0];
        orange = [1 .5 0];
        cm([1:64],:) = strCM;
        cm([65:128],:) = (yellow'*ones(64,1)')';
        cm([129:192],:) = (red'*ones(64,1)')';
        cm([193:256],:) = (orange'*ones(64,1)')';
    else
        %order of colors maps
        cmOrder = spm_input('[Hot Cold Green]','+1','e',[1 2 3]);%added
        cmCell{cmOrder(1)} = hot2;%added
        cmCell{cmOrder(2)} = cold2;%added
        cmCell{cmOrder(3)} = green2;%added
        titleCell{1} = 'Red';
        titleCell{2} = 'Blue';
        titleCell{3} = 'Green';
        titleString = [titleCell{cmOrder(1)},' = 1st Set,',titleCell{cmOrder(2)},' = 2st Set,',titleCell{cmOrder(3)},' = 3st Set,'];
        cm(1:64,:) = strCM;
        for cmN = 1:length(rend{1}.data)
            cm([1:64]+(64*(cmN)),:) = cmCell{cmN};    
        end
    end
    
    

    
    
    
    for i=1:length(rend),
        %--ADDED
        for k=1:length(rend{1}.data)
            if k==1
                ren = rend{i}.ren;
            end
            if(useOverlapColor)
                X = rend{i}.data{k};
            else
                X   = (rend{i}.data{k}-mnmn)/(mxmx-mnmn);
            end
            
            msk = find(X);
            ren(msk) = X(msk)+(k+1.51/size(cm,1));
        end
            ax=axes('Parent',Fgraph,'units','normalized',...
                'Position',[rem(i-1,2)*0.5, floor((i-1)/2)*hght/nrow, 0.5, hght/nrow],...
                'Visible','off');
            image(ren*64,'Parent',ax);
            set(ax,'DataAspectRatio',[1 1 1], ...
                'PlotBoxAspectRatioMode','auto',...
                'YTick',[],'XTick',[],'XDir','normal','YDir','normal');
	end;
                figure(Fgraph);
            colormap(cm);
            title(titleString);
else,
	% Combine the brain surface renderings with the blobs, and display using
	% 24 bit colour.
	%---------------------------------------------------------------
	for i=1:length(rend),
		ren = rend{i}.ren;
		X = cell(3,1);
		for j=1:length(rend{i}.data),
			X{j} = rend{i}.data{j}/(mxmx-mnmn)-mnmn;
		end
		for j=(length(rend{i}.data)+1):3
			X{j}=zeros(size(X{1}));
		end

		rgb = zeros([size(ren) 3]);
		tmp = ren.*max(1-X{1}-X{2}-X{3},0);
		rgb(:,:,1) = tmp + X{1};
		rgb(:,:,2) = tmp + X{2};
		rgb(:,:,3) = tmp + X{3};

		ax=axes('Parent',Fgraph,'units','normalized',...
			'Position',[rem(i-1,2)*0.5, floor((i-1)/2)*hght/nrow, 0.5, hght/nrow],...
			'Visible','off');
		image(rgb,'Parent',ax);
		set(ax,'DataAspectRatio',[1 1 1], ...
			'PlotBoxAspectRatioMode','auto',...
			'YTick',[],'XTick',[],...
			'XDir','normal','YDir','normal');
	end;
end;

spm('Pointer')
return;
